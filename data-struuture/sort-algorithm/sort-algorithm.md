### 排序算法 sort algorithm

* 排序算法的介绍分类

>排序是将一组数据，依次指定的顺序进行排列的过程

* 分类


* 内部排序 将数据一次性加载到内存中进行排序


1.1 插入排序

1.1.1 直接插入排序

1.1.2 希尔排序

1.2 选择排序

1.2.1 简单选择排序

1.2.2 堆排序

1.3 交换排序

1.3.1 冒泡排序

1.3.2 快速排序

1.4 归并排序

1.5 基数排序

* 外部排序 数据量过来，无法一次加载到内存中，需要借助外部存储区


* 算法的时间复杂度

1. 事后统计法

> 注意：1.程序一定要运行 2.程序运行还依赖外部硬件

2. 事前估算法

> 通过分析某个算法的时间复杂度来判断算法的算法优劣

#### 时间频度

* 一个算法花费的时间与算法中语句的执行次数成正比，那个算法中语句执行的次数越多，它花费的时间就越多，一个算法中的语句执行次数称为语句频度或者
时间频度，记为 T(n)

eg:

```php
//计算1-100之和

$i = 1;

$max = 100;

$total = 0;

for ($i = 0; $i < $max; $i++) {
    $total += $i;
}
```

>上述算法的时间频度就是： T(n) = n+1

* 时间频度的估算

1. 忽略常数项 

``T(n) = 2n+20``  ``T(n) = 2n`` 可以忽略常数项 20

2. 忽略低次项

``T(n) = 2n² + 3n + 10``  ``T(n) = 2n²``  可以忽略低次项 3n 和常数项 10

3. 忽略系数

``T(n) = 3n² + 2n``  ``T(n) = 5n²+7n`` 可以忽略前面的系数 3 和 5

* 时间复杂度

> 一般情况下，**算法中的基本操作语句的重复执行的次数是问题规模n的某个函数**，用f(n)表示，若某个辅助函数f(n),使得当趋于无穷大时，
**T(n)/f(n)** 的极限值为不等于0的一个常数，则称为f(n)时T(n)的同数量级函数，记作T(n) = O(f(n)),称O(f(n))为算法的渐进时间复杂度，
简称时间复杂度。

* T(n)不同，但时间复杂度可能相同，`2n²+7n+6`  `3n²+2n+2`,它们的T(n)不同，但是时间复杂度相同，**都为O(n²)**

* 计算时间复杂度的方法：

1. 用常数 1 代替运行时间中的所有加法常数 `2n²+7n+1`

2. 修改后的运行次数函数中，只保留最高阶项 `2n²`

3. 去除最高阶项的系数 `n²`

#### 常见的时间复杂度

1. **常数阶** 1

```php
$i = 1;
$j = 10;
$i++;
++$j;
echo $i + $j;
```

2. **对数阶** ㏒2N

```php
//N = a²  a的2次方等于N，a>0 a != 1; 叫做以2为底的a的对数 ==》 ㏒₂a

$i = 1;
$n = 1024;

while($i < $n) {
    $i = $i * 2
}
```

3. **线性阶** n

```php
$n = 10;
for($i = 0; $i < $n; $i++) {
    echo $i;
}
```

4. **线性对数阶** n㏒₂n

```php
$n = 10;
$m = 1024;
$j = 1;

for($i = 0; $i < $n; $i++) {
    while($j < $m) {
        $j = $i * 2;
    }
}
```

5. **平方阶** n²

```php
<?php
for ($i = 0; $i < 100; $i++) {
    for ($j = 0; $j < 100; $j++) {
        echo $i * $j;
    }
}
?>
```

6. **立方阶** n³

```php
<?php
for ($i = 0; $i < 100; $i++) {
    for ($j = 0; $j < 100; $j++) {
        for ($m = 0; $m < 100; $m++) {
            echo $i * $j * $m;
        }
    }
}
?>
```

7. **k次方阶** n*

8. **指数阶** 2^n

* 算法时间复杂度的大小关系，常数阶 < 对数阶 < 线性阶 < 线性对数阶 < 平方阶 < 立方阶 < k次方阶 < 指数阶

* 算法时间复杂度之平均时间复杂度和最坏时间复杂度

算法   复杂度

冒泡   O(n²)

交换   O(n²)

插入   O(n²)

基数   O(n²)

希尔   O(㏒₂2)

快速   O(㏒₂2)

归并   O(㏒₂2)

堆     O(㏒₂2)


#### 排序实现

* 冒泡排序


